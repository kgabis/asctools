package asctools

import (
	"bufio"
	"math"
	"unsafe"
)

const epsilon = 0.0001

type Vector3 struct {
	X, Y, Z float32
}

type Triangle struct {
	Normal  Vector3
	Vertex1 Vector3
	Vertex2 Vector3
	Vertex3 Vector3
}

func (elevationMap *ElevationMap) WriteSTL(writer *bufio.Writer, floorElevation float64) error {
	header := make([]byte, 80)
	copy(header, []byte("STL binary file generated by asctools"))

	numTriangles := countTriangles(elevationMap)

	writer.Write(header)

	writer.Write([]byte{
		byte(numTriangles),
		byte(numTriangles >> 8),
		byte(numTriangles >> 16),
		byte(numTriangles >> 24),
	})

	writeTriangle := func(t Triangle) {
		writeFloat32(writer, t.Normal.X)
		writeFloat32(writer, t.Normal.Y)
		writeFloat32(writer, t.Normal.Z)

		writeFloat32(writer, t.Vertex1.X)
		writeFloat32(writer, t.Vertex1.Y)
		writeFloat32(writer, t.Vertex1.Z)

		writeFloat32(writer, t.Vertex2.X)
		writeFloat32(writer, t.Vertex2.Y)
		writeFloat32(writer, t.Vertex2.Z)

		writeFloat32(writer, t.Vertex3.X)
		writeFloat32(writer, t.Vertex3.Y)
		writeFloat32(writer, t.Vertex3.Z)

		writer.Write([]byte{0, 0})
	}

	generateAndWriteTriangles(elevationMap, floorElevation, writeTriangle)

	return writer.Flush()
}

func writeFloat32(writer *bufio.Writer, f float32) {
	bits := *(*uint32)(unsafe.Pointer(&f))
	writer.Write([]byte{
		byte(bits),
		byte(bits >> 8),
		byte(bits >> 16),
		byte(bits >> 24),
	})
}

func countTriangles(elevationMap *ElevationMap) int {
	rows := elevationMap.NumRows
	cols := elevationMap.NumCols

	count := (rows - 1) * (cols - 1) * 2
	count += 4 * (rows + cols - 2)
	count += 2

	return count
}

func generateAndWriteTriangles(elevationMap *ElevationMap, floorElevation float64, writeTriangle func(Triangle)) {
	corner1 := Vector3{0, 0, 0}
	corner2 := Vector3{float32(elevationMap.GetWidth()), 0, 0}
	corner3 := Vector3{0, float32(elevationMap.GetHeight()), 0}
	corner4 := Vector3{float32(elevationMap.GetWidth()), float32(elevationMap.GetHeight()), 0}

	writeTriangle(makeTriangle(corner1, corner3, corner2))
	writeTriangle(makeTriangle(corner2, corner3, corner4))

	step := elevationMap.CellSize
	for y := elevationMap.MinY; y < (elevationMap.MaxY - step); y += step {
		for x := elevationMap.MinX; x < (elevationMap.MaxX - step); x += step {
			e1 := elevationMap.GetElevation(x, y)
			e2 := elevationMap.GetElevation(x+step, y)
			e3 := elevationMap.GetElevation(x, y+step)
			e4 := elevationMap.GetElevation(x+step, y+step)

			if e1 == NodataValue {
				e1 = floorElevation + epsilon
			} else {
				e1 -= floorElevation
			}

			if e2 == NodataValue {
				e2 = floorElevation
			} else {
				e2 -= floorElevation
			}

			if e3 == NodataValue {
				e3 = floorElevation
			} else {
				e3 -= floorElevation
			}

			if e4 == NodataValue {
				e4 = floorElevation
			} else {
				e4 -= floorElevation
			}

			v1 := Vector3{float32(x - elevationMap.MinX), float32(y - elevationMap.MinY), float32(e1)}
			v2 := Vector3{float32(x + step - elevationMap.MinX), float32(y - elevationMap.MinY), float32(e2)}
			v3 := Vector3{float32(x - elevationMap.MinX), float32(y + step - elevationMap.MinY), float32(e3)}
			v4 := Vector3{float32(x + step - elevationMap.MinX), float32(y + step - elevationMap.MinY), float32(e4)}

			if e3 < 0 || e2 < 0 {
				if v1.Z >= 0 && v4.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v1, v4, v3))
				}
				if v1.Z >= 0 && v2.Z >= 0 && v4.Z >= 0 {
					writeTriangle(makeTriangle(v1, v2, v4))
				}
			} else {
				if v1.Z >= 0 && v2.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v1, v2, v3))
				}
				if v2.Z >= 0 && v4.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v2, v4, v3))
				}
			}

			isFirstRow := areFloatsEqual(y, elevationMap.MinY)
			isLastRow := areFloatsEqual(y, elevationMap.MaxY-2*step)
			isFirstCol := areFloatsEqual(x, elevationMap.MinX)
			isLastCol := areFloatsEqual(x, elevationMap.MaxX-2*step)
			if (e1 >= 0 && (isFirstCol || elevationMap.GetElevation(x, y-step) < floorElevation)) && (e3 >= 0) && (isFirstCol || elevationMap.GetElevation(y+step, x-step) < floorElevation) {
				writeWall(v1, v3, writeTriangle)
			}

			if (e2 >= 0 && (isLastCol || elevationMap.GetElevation(x+2*step, y) < floorElevation)) && (e4 >= 0) && (isLastCol || elevationMap.GetElevation(x+2*step, y+step) < floorElevation) {
				writeWall(v4, v2, writeTriangle)
			}

			if (e1 >= 0 && (isFirstRow || elevationMap.GetElevation(x, y-step) < floorElevation)) && (e2 >= 0) && (isFirstRow || elevationMap.GetElevation(x+step, y-step) < floorElevation) {
				writeWall(v2, v1, writeTriangle)
			}

			if (e3 >= 0 && (isLastRow || elevationMap.GetElevation(x, y+2*step) < floorElevation)) && (e4 >= 0) && (isLastRow || elevationMap.GetElevation(x+step, y+2*step) < floorElevation) {
				writeWall(v3, v4, writeTriangle)
			}

			if e1 >= 0 && e4 < 0 && e2 >= 0 && e3 >= 0 {
				writeWall(v3, v2, writeTriangle)
			}

			if e1 < 0 && e4 >= 0 && e2 >= 0 && e3 >= 0 {
				writeWall(v2, v3, writeTriangle)
			}

			if e2 >= 0 && e3 < 0 && e1 >= 0 && e4 >= 0 {
				writeWall(v1, v4, writeTriangle)
			}

			if e2 < 0 && e3 >= 0 && e1 >= 0 && e4 >= 0 {
				writeWall(v4, v1, writeTriangle)
			}
		}
	}
}

func makeTriangle(v1, v2, v3 Vector3) Triangle {
	return Triangle{
		Normal:  calculateNormal(v1, v2, v3),
		Vertex1: v1,
		Vertex2: v2,
		Vertex3: v3,
	}
}

func writeWall(v1, v2 Vector3, writeTriangle func(Triangle)) {
	v1floor := Vector3{v1.X, v1.Y, 0}
	v2floor := Vector3{v2.X, v2.Y, 0}

	writeTriangle(makeTriangle(v1, v2, v1floor))
	writeTriangle(makeTriangle(v2, v2floor, v1floor))
}

func calculateNormal(p1, p2, p3 Vector3) Vector3 {
	edge1 := Vector3{
		X: p2.X - p1.X,
		Y: p2.Y - p1.Y,
		Z: p2.Z - p1.Z,
	}

	edge2 := Vector3{
		X: p3.X - p1.X,
		Y: p3.Y - p1.Y,
		Z: p3.Z - p1.Z,
	}

	normal := Vector3{
		X: edge1.Y*edge2.Z - edge1.Z*edge2.Y,
		Y: edge1.Z*edge2.X - edge1.X*edge2.Z,
		Z: edge1.X*edge2.Y - edge1.Y*edge2.X,
	}

	length := float32(math.Sqrt(float64(normal.X*normal.X + normal.Y*normal.Y + normal.Z*normal.Z)))

	if length > 0 {
		normal.X /= length
		normal.Y /= length
		normal.Z /= length
	}

	return normal
}

func areFloatsEqual(a, b float64) bool {
	return math.Abs(a-b) < epsilon
}
