package asctools

import (
	"bufio"
	"math"
	"unsafe"
)

type Vector3 struct {
	X, Y, Z float32
}

type Triangle struct {
	Normal  Vector3
	Vertex1 Vector3
	Vertex2 Vector3
	Vertex3 Vector3
}

func (elevationMap *ElevationMap) WriteSTL(writer *bufio.Writer, floorElevation float64) error {
	header := make([]byte, 80)
	copy(header, []byte("STL binary file generated by asctools"))

	numTriangles := countTriangles(elevationMap)

	writer.Write(header)

	writer.Write([]byte{
		byte(numTriangles),
		byte(numTriangles >> 8),
		byte(numTriangles >> 16),
		byte(numTriangles >> 24),
	})

	writeTriangle := func(t Triangle) {
		writeFloat32(writer, t.Normal.X)
		writeFloat32(writer, t.Normal.Y)
		writeFloat32(writer, t.Normal.Z)

		writeFloat32(writer, t.Vertex1.X)
		writeFloat32(writer, t.Vertex1.Y)
		writeFloat32(writer, t.Vertex1.Z)

		writeFloat32(writer, t.Vertex2.X)
		writeFloat32(writer, t.Vertex2.Y)
		writeFloat32(writer, t.Vertex2.Z)

		writeFloat32(writer, t.Vertex3.X)
		writeFloat32(writer, t.Vertex3.Y)
		writeFloat32(writer, t.Vertex3.Z)

		writer.Write([]byte{0, 0})
	}

	generateAndWriteTriangles(elevationMap, floorElevation, writeTriangle)

	return writer.Flush()
}

func writeFloat32(writer *bufio.Writer, f float32) {
	bits := *(*uint32)(unsafe.Pointer(&f))
	writer.Write([]byte{
		byte(bits),
		byte(bits >> 8),
		byte(bits >> 16),
		byte(bits >> 24),
	})
}

func countTriangles(elevationMap *ElevationMap) int {
	rows := elevationMap.NumRows
	cols := elevationMap.NumCols

	count := (rows - 1) * (cols - 1) * 2
	count += 4 * (rows + cols - 2)
	count += 2

	return count
}

func generateAndWriteTriangles(elevationMap *ElevationMap, floorElevation float64, writeTriangle func(Triangle)) {
	corner1 := Vector3{0, 0, 0}
	corner2 := Vector3{float32(elevationMap.GetWidth()), 0, 0}
	corner3 := Vector3{0, float32(elevationMap.GetHeight()), 0}
	corner4 := Vector3{float32(elevationMap.GetWidth()), float32(elevationMap.GetHeight()), 0}

	writeTriangle(makeTriangle(corner1, corner3, corner2))
	writeTriangle(makeTriangle(corner2, corner3, corner4))

	epsilon := 0.0001

	for row := 0; row < elevationMap.NumRows-1; row++ {
		for col := 0; col < elevationMap.NumCols-1; col++ {
			e1 := elevationMap.GetRowCol(row, col, true)
			e2 := elevationMap.GetRowCol(row, col+1, true)
			e3 := elevationMap.GetRowCol(row+1, col, true)
			e4 := elevationMap.GetRowCol(row+1, col+1, true)

			if e1 == NodataValue {
				e1 = floorElevation + epsilon
			} else {
				e1 -= floorElevation
			}

			if e2 == NodataValue {
				e2 = floorElevation
			} else {
				e2 -= floorElevation
			}

			if e3 == NodataValue {
				e3 = floorElevation
			} else {
				e3 -= floorElevation
			}

			if e4 == NodataValue {
				e4 = floorElevation
			} else {
				e4 -= floorElevation
			}

			v1 := Vector3{float32(col), float32(row), float32(e1)}
			v2 := Vector3{float32(col + 1), float32(row), float32(e2)}
			v3 := Vector3{float32(col), float32(row + 1), float32(e3)}
			v4 := Vector3{float32(col + 1), float32(row + 1), float32(e4)}

			v1.X *= float32(elevationMap.CellSize)
			v1.Y *= float32(elevationMap.CellSize)
			v2.X *= float32(elevationMap.CellSize)
			v2.Y *= float32(elevationMap.CellSize)
			v3.X *= float32(elevationMap.CellSize)
			v3.Y *= float32(elevationMap.CellSize)
			v4.X *= float32(elevationMap.CellSize)
			v4.Y *= float32(elevationMap.CellSize)

			if e3 < 0 || e2 < 0 {
				if v1.Z >= 0 && v4.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v1, v4, v3))
				}
				if v1.Z >= 0 && v2.Z >= 0 && v4.Z >= 0 {
					writeTriangle(makeTriangle(v1, v2, v4))
				}
			} else {
				if v1.Z >= 0 && v2.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v1, v2, v3))
				}
				if v2.Z >= 0 && v4.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v2, v4, v3))
				}
			}

			if (e1 >= 0 && (col == 0 || elevationMap.GetRowCol(row, col-1, true) < floorElevation)) && (e3 >= 0) && (col == 0 || elevationMap.GetRowCol(row+1, col-1, true) < floorElevation) {
				writeWall(v1, v3, writeTriangle)
			}

			if (e2 >= 0 && (col == elevationMap.NumCols-2 || elevationMap.GetRowCol(row, col+2, true) < floorElevation)) && (e4 >= 0) && (col == elevationMap.NumCols-2 || elevationMap.GetRowCol(row+1, col+2, true) < floorElevation) {
				writeWall(v4, v2, writeTriangle)
			}

			if (e1 >= 0 && (row == 0 || elevationMap.GetRowCol(row-1, col, true) < floorElevation)) && (e2 >= 0) && (row == 0 || elevationMap.GetRowCol(row-1, col+1, true) < floorElevation) {
				writeWall(v2, v1, writeTriangle)
			}

			if (e3 >= 0 && (row == elevationMap.NumRows-2 || elevationMap.GetRowCol(row+2, col, true) < floorElevation)) && (e4 >= 0) && (row == elevationMap.NumRows-2 || elevationMap.GetRowCol(row+2, col+1, true) < floorElevation) {
				writeWall(v3, v4, writeTriangle)
			}

			if e1 >= 0 && e4 < 0 && e2 >= 0 && e3 >= 0 {
				writeWall(v3, v2, writeTriangle)
			}

			if e1 < 0 && e4 >= 0 && e2 >= 0 && e3 >= 0 {
				writeWall(v2, v3, writeTriangle)
			}

			if e2 >= 0 && e3 < 0 && e1 >= 0 && e4 >= 0 {
				writeWall(v1, v4, writeTriangle)
			}

			if e2 < 0 && e3 >= 0 && e1 >= 0 && e4 >= 0 {
				writeWall(v4, v1, writeTriangle)
			}
		}
	}
}

func makeTriangle(v1, v2, v3 Vector3) Triangle {
	return Triangle{
		Normal:  calculateNormal(v1, v2, v3),
		Vertex1: v1,
		Vertex2: v2,
		Vertex3: v3,
	}
}

func writeWall(v1, v2 Vector3, writeTriangle func(Triangle)) {
	v1floor := Vector3{v1.X, v1.Y, 0}
	v2floor := Vector3{v2.X, v2.Y, 0}

	writeTriangle(makeTriangle(v1, v2, v1floor))
	writeTriangle(makeTriangle(v2, v2floor, v1floor))
}

func calculateNormal(p1, p2, p3 Vector3) Vector3 {
	edge1 := Vector3{
		X: p2.X - p1.X,
		Y: p2.Y - p1.Y,
		Z: p2.Z - p1.Z,
	}

	edge2 := Vector3{
		X: p3.X - p1.X,
		Y: p3.Y - p1.Y,
		Z: p3.Z - p1.Z,
	}

	normal := Vector3{
		X: edge1.Y*edge2.Z - edge1.Z*edge2.Y,
		Y: edge1.Z*edge2.X - edge1.X*edge2.Z,
		Z: edge1.X*edge2.Y - edge1.Y*edge2.X,
	}

	length := float32(math.Sqrt(float64(normal.X*normal.X + normal.Y*normal.Y + normal.Z*normal.Z)))

	if length > 0 {
		normal.X /= length
		normal.Y /= length
		normal.Z /= length
	}

	return normal
}
