package asctools

import (
	"bufio"
	"math"
	"unsafe"
)

type Vector3 struct {
	X, Y, Z float64
}

type Triangle struct {
	Normal  Vector3
	Vertex1 Vector3
	Vertex2 Vector3
	Vertex3 Vector3
}

func (elevationMap *ElevationMap) WriteSTL(writer *bufio.Writer, floorElevation float64) error {
	header := make([]byte, 80)
	copy(header, []byte("STL binary file generated by asctools"))

	// First pass: count triangles
	numTriangles := countTriangles(elevationMap, floorElevation)

	// Write header
	writer.Write(header)

	// Write triangle count
	writer.Write([]byte{
		byte(numTriangles),
		byte(numTriangles >> 8),
		byte(numTriangles >> 16),
		byte(numTriangles >> 24),
	})

	// Second pass: generate and write triangles on-the-fly
	flushCounter := 0
	writeTriangle := func(t Triangle) {
		writeFloat32(writer, float32(t.Normal.X))
		writeFloat32(writer, float32(t.Normal.Y))
		writeFloat32(writer, float32(t.Normal.Z))

		writeFloat32(writer, float32(t.Vertex1.X))
		writeFloat32(writer, float32(t.Vertex1.Y))
		writeFloat32(writer, float32(t.Vertex1.Z))

		writeFloat32(writer, float32(t.Vertex2.X))
		writeFloat32(writer, float32(t.Vertex2.Y))
		writeFloat32(writer, float32(t.Vertex2.Z))

		writeFloat32(writer, float32(t.Vertex3.X))
		writeFloat32(writer, float32(t.Vertex3.Y))
		writeFloat32(writer, float32(t.Vertex3.Z))

		writer.Write([]byte{0, 0})

		flushCounter++
		if flushCounter%1000 == 0 {
			writer.Flush()
		}
	}

	generateAndWriteTriangles(elevationMap, floorElevation, writeTriangle)

	return writer.Flush()
}

func writeFloat32(writer *bufio.Writer, f float32) {
	bits := *(*uint32)(unsafe.Pointer(&f))
	writer.Write([]byte{
		byte(bits),
		byte(bits >> 8),
		byte(bits >> 16),
		byte(bits >> 24),
	})
}

// countTriangles counts how many triangles will be generated (first pass)
func countTriangles(elevationMap *ElevationMap, floorElevation float64) uint32 {
	count := uint32(0)

	// Floor corners
	count += 2

	elevationData := elevationMap.Data
	for y := 0; y < len(elevationData)-1; y++ {
		for x := 0; x < len(elevationData[y])-1; x++ {
			e1 := elevationData[y][x] - floorElevation
			e2 := elevationData[y][x+1] - floorElevation
			e3 := elevationData[y+1][x] - floorElevation
			e4 := elevationData[y+1][x+1] - floorElevation

			// Top surface triangles
			if e3 < 0 || e2 < 0 {
				if e1 >= 0 && e4 >= 0 && e3 >= 0 {
					count++
				}
				if e1 >= 0 && e2 >= 0 && e4 >= 0 {
					count++
				}
			} else {
				if e1 >= 0 && e2 >= 0 && e3 >= 0 {
					count++
				}
				if e2 >= 0 && e4 >= 0 && e3 >= 0 {
					count++
				}
			}

			// Wall triangles (each wall adds 2 triangles)
			if (e1 >= 0 && (x == 0 || elevationData[y][x-1] < floorElevation)) && (e3 >= 0) && (x == 0 || elevationData[y+1][x-1] < floorElevation) {
				count += 2
			}

			if (e2 >= 0 && (x == len(elevationData[y])-2 || elevationData[y][x+2] < floorElevation)) && (e4 >= 0) && (x == len(elevationData[y])-2 || elevationData[y+1][x+2] < floorElevation) {
				count += 2
			}

			if (e1 >= 0 && (y == 0 || elevationData[y-1][x] < floorElevation)) && (e2 >= 0) && (y == 0 || elevationData[y-1][x+1] < floorElevation) {
				count += 2
			}

			if (e3 >= 0 && (y == len(elevationData)-2 || elevationData[y+2][x] < floorElevation)) && (e4 >= 0) && (y == len(elevationData)-2 || elevationData[y+2][x+1] < floorElevation) {
				count += 2
			}

			if e1 >= 0 && e4 < 0 && e2 >= 0 && e3 >= 0 {
				count += 2
			}

			if e1 < 0 && e4 >= 0 && e2 >= 0 && e3 >= 0 {
				count += 2
			}

			if e2 >= 0 && e3 < 0 && e1 >= 0 && e4 >= 0 {
				count += 2
			}

			if e2 < 0 && e3 >= 0 && e1 >= 0 && e4 >= 0 {
				count += 2
			}
		}
	}

	return count
}

// generateAndWriteTriangles generates triangles and writes them immediately (second pass)
func generateAndWriteTriangles(elevationMap *ElevationMap, floorElevation float64, writeTriangle func(Triangle)) {
	corner1 := Vector3{0, 0, 0}
	corner2 := Vector3{elevationMap.GetWidth(), 0, 0}
	corner3 := Vector3{0, elevationMap.GetHeight(), 0}
	corner4 := Vector3{elevationMap.GetWidth(), elevationMap.GetHeight(), 0}

	writeTriangle(makeTriangle(corner1, corner3, corner2))
	writeTriangle(makeTriangle(corner2, corner3, corner4))

	elevationData := elevationMap.Data

	for y := 0; y < len(elevationData)-1; y++ {
		for x := 0; x < len(elevationData[y])-1; x++ {
			e1 := elevationData[y][x] - floorElevation
			e2 := elevationData[y][x+1] - floorElevation
			e3 := elevationData[y+1][x] - floorElevation
			e4 := elevationData[y+1][x+1] - floorElevation

			v1 := Vector3{float64(x), float64(y), e1}
			v2 := Vector3{float64(x + 1), float64(y), e2}
			v3 := Vector3{float64(x), float64(y + 1), e3}
			v4 := Vector3{float64(x + 1), float64(y + 1), e4}

			if elevationMap.CellSize != 0 {
				v1.X *= elevationMap.CellSize
				v1.Y *= elevationMap.CellSize
				v2.X *= elevationMap.CellSize
				v2.Y *= elevationMap.CellSize
				v3.X *= elevationMap.CellSize
				v3.Y *= elevationMap.CellSize
				v4.X *= elevationMap.CellSize
				v4.Y *= elevationMap.CellSize
			}

			if e3 < 0 || e2 < 0 {
				if v1.Z >= 0 && v4.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v1, v4, v3))
				}
				if v1.Z >= 0 && v2.Z >= 0 && v4.Z >= 0 {
					writeTriangle(makeTriangle(v1, v2, v4))
				}
			} else {
				if v1.Z >= 0 && v2.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v1, v2, v3))
				}
				if v2.Z >= 0 && v4.Z >= 0 && v3.Z >= 0 {
					writeTriangle(makeTriangle(v2, v4, v3))
				}
			}

			if (e1 >= 0 && (x == 0 || elevationData[y][x-1] < floorElevation)) && (e3 >= 0) && (x == 0 || elevationData[y+1][x-1] < floorElevation) {
				writeWall(v1, v3, writeTriangle)
			}

			if (e2 >= 0 && (x == len(elevationData[y])-2 || elevationData[y][x+2] < floorElevation)) && (e4 >= 0) && (x == len(elevationData[y])-2 || elevationData[y+1][x+2] < floorElevation) {
				writeWall(v4, v2, writeTriangle)
			}

			if (e1 >= 0 && (y == 0 || elevationData[y-1][x] < floorElevation)) && (e2 >= 0) && (y == 0 || elevationData[y-1][x+1] < floorElevation) {
				writeWall(v2, v1, writeTriangle)
			}

			if (e3 >= 0 && (y == len(elevationData)-2 || elevationData[y+2][x] < floorElevation)) && (e4 >= 0) && (y == len(elevationData)-2 || elevationData[y+2][x+1] < floorElevation) {
				writeWall(v3, v4, writeTriangle)
			}

			if e1 >= 0 && e4 < 0 && e2 >= 0 && e3 >= 0 {
				writeWall(v3, v2, writeTriangle)
			}

			if e1 < 0 && e4 >= 0 && e2 >= 0 && e3 >= 0 {
				writeWall(v2, v3, writeTriangle)
			}

			if e2 >= 0 && e3 < 0 && e1 >= 0 && e4 >= 0 {
				writeWall(v1, v4, writeTriangle)
			}

			if e2 < 0 && e3 >= 0 && e1 >= 0 && e4 >= 0 {
				writeWall(v4, v1, writeTriangle)
			}
		}
	}
}

func makeTriangle(v1, v2, v3 Vector3) Triangle {
	return Triangle{
		Normal:  calculateNormal(v1, v2, v3),
		Vertex1: v1,
		Vertex2: v2,
		Vertex3: v3,
	}
}

func writeWall(v1, v2 Vector3, writeTriangle func(Triangle)) {
	v1floor := Vector3{v1.X, v1.Y, 0}
	v2floor := Vector3{v2.X, v2.Y, 0}

	writeTriangle(makeTriangle(v1, v2, v1floor))
	writeTriangle(makeTriangle(v2, v2floor, v1floor))
}

func calculateNormal(p1, p2, p3 Vector3) Vector3 {
	edge1 := Vector3{
		X: p2.X - p1.X,
		Y: p2.Y - p1.Y,
		Z: p2.Z - p1.Z,
	}

	edge2 := Vector3{
		X: p3.X - p1.X,
		Y: p3.Y - p1.Y,
		Z: p3.Z - p1.Z,
	}

	normal := Vector3{
		X: edge1.Y*edge2.Z - edge1.Z*edge2.Y,
		Y: edge1.Z*edge2.X - edge1.X*edge2.Z,
		Z: edge1.X*edge2.Y - edge1.Y*edge2.X,
	}

	length := math.Sqrt(float64(normal.X*normal.X + normal.Y*normal.Y + normal.Z*normal.Z))

	if length > 0 {
		normal.X /= length
		normal.Y /= length
		normal.Z /= length
	}

	return normal
}
