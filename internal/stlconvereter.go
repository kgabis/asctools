package lidartools

import (
	"bufio"
	"math"
	"unsafe"
)

type Vector3 struct {
	X, Y, Z float64
}

type Triangle struct {
	Normal  Vector3
	Vertex1 Vector3
	Vertex2 Vector3
	Vertex3 Vector3
}

func (elevationMap *ElevationMap) WriteSTL(writer *bufio.Writer, floorElevation float64) error {
	header := make([]byte, 80)
	copy(header, []byte("STL binary file generated by Go"))

	triangles := createTriangles(elevationMap, floorElevation)

	writer.Write(header)

	numTriangles := uint32(len(triangles))
	writer.Write([]byte{
		byte(numTriangles),
		byte(numTriangles >> 8),
		byte(numTriangles >> 16),
		byte(numTriangles >> 24),
	})

	for _, t := range triangles {
		writeFloat32(writer, float32(t.Normal.X))
		writeFloat32(writer, float32(t.Normal.Y))
		writeFloat32(writer, float32(t.Normal.Z))

		writeFloat32(writer, float32(t.Vertex1.X))
		writeFloat32(writer, float32(t.Vertex1.Y))
		writeFloat32(writer, float32(t.Vertex1.Z))

		writeFloat32(writer, float32(t.Vertex2.X))
		writeFloat32(writer, float32(t.Vertex2.Y))
		writeFloat32(writer, float32(t.Vertex2.Z))

		writeFloat32(writer, float32(t.Vertex3.X))
		writeFloat32(writer, float32(t.Vertex3.Y))
		writeFloat32(writer, float32(t.Vertex3.Z))

		writer.Write([]byte{0, 0})
	}

	return writer.Flush()
}

func writeFloat32(writer *bufio.Writer, f float32) {
	bits := *(*uint32)(unsafe.Pointer(&f))
	writer.Write([]byte{
		byte(bits),
		byte(bits >> 8),
		byte(bits >> 16),
		byte(bits >> 24),
	})
}

func addTriangle(triangles []Triangle, v1 Vector3, v2 Vector3, v3 Vector3) []Triangle {
	return append(triangles, Triangle{
		Normal:  calculateNormal(v1, v2, v3),
		Vertex1: v1,
		Vertex2: v2,
		Vertex3: v3,
	})
}

func addWall(triangles []Triangle, v1 Vector3, v2 Vector3) []Triangle {
	v1floor := Vector3{v1.X, v1.Y, 0}
	v2floor := Vector3{v2.X, v2.Y, 0}

	triangles = addTriangle(triangles, v1, v2, v1floor)
	triangles = addTriangle(triangles, v2, v2floor, v1floor)

	return triangles
}

func createTriangles(elevationMap *ElevationMap, floorElevation float64) []Triangle {
	var triangles []Triangle

	corner1 := Vector3{0, 0, floorElevation}
	corner2 := Vector3{elevationMap.GetWidth(), 0, floorElevation}
	corner3 := Vector3{0, elevationMap.GetHeight(), floorElevation}
	corner4 := Vector3{elevationMap.GetWidth(), elevationMap.GetHeight(), floorElevation}

	triangles = addTriangle(triangles, corner1, corner3, corner2)
	triangles = addTriangle(triangles, corner2, corner3, corner4)
	elevationData := elevationMap.Data

	for y := 0; y < len(elevationData)-1; y++ {
		for x := 0; x < len(elevationData[y])-1; x++ {
			e1 := elevationData[y][x] - floorElevation
			e2 := elevationData[y][x+1] - floorElevation
			e3 := elevationData[y+1][x] - floorElevation
			e4 := elevationData[y+1][x+1] - floorElevation

			v1 := Vector3{float64(x), float64(y), e1}
			v2 := Vector3{float64(x + 1), float64(y), e2}
			v3 := Vector3{float64(x), float64(y + 1), e3}
			v4 := Vector3{float64(x + 1), float64(y + 1), e4}

			if elevationMap.CellSize != 0 {
				v1.X *= elevationMap.CellSize
				v1.Y *= elevationMap.CellSize
				v2.X *= elevationMap.CellSize
				v2.Y *= elevationMap.CellSize
				v3.X *= elevationMap.CellSize
				v3.Y *= elevationMap.CellSize
				v4.X *= elevationMap.CellSize
				v4.Y *= elevationMap.CellSize
			}

			if e3 < 0 || e2 < 0 {
				if v1.Z >= 0 && v4.Z >= 0 && v3.Z >= 0 {
					triangles = addTriangle(triangles, v1, v4, v3)
				}
				if v1.Z >= 0 && v2.Z >= 0 && v4.Z >= 0 {
					triangles = addTriangle(triangles, v1, v2, v4)
				}
			} else {
				if v1.Z >= 0 && v2.Z >= 0 && v3.Z >= 0 {
					triangles = addTriangle(triangles, v1, v2, v3)
				}
				if v2.Z >= 0 && v4.Z >= 0 && v3.Z >= 0 {
					triangles = addTriangle(triangles, v2, v4, v3)
				}
			}

			if (e1 >= 0 && (x == 0 || elevationData[y][x-1] < 0)) && (e3 >= 0) && (x == 0 || elevationData[y+1][x-1] < 0) {
				triangles = addWall(triangles, v1, v3)
			}

			if (e2 >= 0 && (x == len(elevationData[y])-2 || elevationData[y][x+2] < 0)) && (e4 >= 0) && (x == len(elevationData[y])-2 || elevationData[y+1][x+2] < 0) {
				triangles = addWall(triangles, v4, v2)
			}

			if (e1 >= 0 && (y == 0 || elevationData[y-1][x] < 0)) && (e2 >= 0) && (y == 0 || elevationData[y-1][x+1] < 0) {
				triangles = addWall(triangles, v2, v1)
			}

			if (e3 >= 0 && (y == len(elevationData)-2 || elevationData[y+2][x] < 0)) && (e4 >= 0) && (y == len(elevationData)-2 || elevationData[y+2][x+1] < 0) {
				triangles = addWall(triangles, v3, v4)
			}

			if e1 >= 0 && e4 < 0 && e2 >= 0 && e3 >= 0 {
				triangles = addWall(triangles, v3, v2)
			}

			if e1 < 0 && e4 >= 0 && e2 >= 0 && e3 >= 0 {
				triangles = addWall(triangles, v2, v3)
			}

			if e2 >= 0 && e3 < 0 && e1 >= 0 && e4 >= 0 {
				triangles = addWall(triangles, v1, v4)
			}

			if e2 < 0 && e3 >= 0 && e1 >= 0 && e4 >= 0 {
				triangles = addWall(triangles, v4, v1)
			}
		}
	}

	return triangles
}

func calculateNormal(p1, p2, p3 Vector3) Vector3 {
	edge1 := Vector3{
		X: p2.X - p1.X,
		Y: p2.Y - p1.Y,
		Z: p2.Z - p1.Z,
	}

	edge2 := Vector3{
		X: p3.X - p1.X,
		Y: p3.Y - p1.Y,
		Z: p3.Z - p1.Z,
	}

	normal := Vector3{
		X: edge1.Y*edge2.Z - edge1.Z*edge2.Y,
		Y: edge1.Z*edge2.X - edge1.X*edge2.Z,
		Z: edge1.X*edge2.Y - edge1.Y*edge2.X,
	}

	length := math.Sqrt(float64(normal.X*normal.X + normal.Y*normal.Y + normal.Z*normal.Z))

	if length > 0 {
		normal.X /= length
		normal.Y /= length
		normal.Z /= length
	}

	return normal
}
